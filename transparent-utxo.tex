\section{Transparent UTXO-based Wallets}

A transaction description specifies the desired outputs of a transaction and a fee. In the simplest case of sending some funds to a specific address, the transaction description is comprised of a single P2PKH output.

A wallet needs to be able to turn a transaction description into a valid transaction that will be accepted by full nodes in a process called funding. To fund a transaction description, the wallet performs the following steps:

\begin{itemize}
    \item Collect a set $S$ of unspent transaction outputs spendable by public keys derivable from the seed such that $$\sum_{o \in S} o.\text{value} \ge \textsf{value}$$
    \item Create a change output directed back to a public key derivable by the seed such that
    $$\sum_{input} input.\text{value} - \sum_{output} output.\text{value} = \textsf{fee}$$
    \item For each unspent transaction output in $S$, generate its unlocking script and use it as an input. In the typical case the unlocking script includes the signature of said transaction with the secret key of said output recipient.
\end{itemize}

The balance of a wallet can be obtained as the sum of the values of all unspent outputs destined to public keys derivable from the seed.

The transaction history of a wallet can be extracted from the set of all transactions implicating public keys derivable from the seed. Specifically, inputs where are spent by some private key derivable from the seed are debits, and outputs which are directed to some public key derivable from the seed are credits.

\subsection{Full Node}
%Full node wallets plug directly to a full node. The full node 
The best known example of a full node wallet is Bitcoin-Qt.

A full node contains in its state the complete chain with full blocks, that include all of their transactions. In addition, the chain is assumed to be verified for validity.

\paragraph{Transaction history \& Spending.}
When presented with a seed, the full node wallet starts evaluating all transactions in every block from genesis up to the tip to detect which ones implicate the user's seed. This process is linear in the chain size, henceforth $O(n)$.

\paragraph{Only Balance \& Spending (Pruned mode).}
When presented with a seed in pruned mode, a full node wallet can only evaluate all outputs in the UTXO to detect the user's current spendable balance. In this way, the transaction history is not known but new transactions can be generated without a problem. One shortcoming of this approach is the additional assumption that we know the maximum nonce in use with the user's seed. We must assume a maximum nonce in order to generate a list of possible addresses of the user and scan the UTXO for outputs directed to them.

If the UTXO is stored as a list, then every entry must be checked, which yields performance of $O(|utxo|)$. However, the UTXO can easily be indexed by address, which makes detection $O(maxnonce)$.
\subsection{BIP-37 SPV}
SPV was first described in the Bitcoin whitepaper~\cite{bitcoin}.
The idea is as follows, a light node only requests and holds the header chain, that is only the header part of each block (which in Bitcoin is 80 bytes) and not the full block. When someone wishes to prove a transaction took place to an SPV node, they need to provide (a) the transaction (b) the id of the block that contains it and (c) a Merkle proof of inclusion to the Merkle root included in said block. The SPV node can check that the claimed block is part of its local best header chain and the Merkle proof provided is valid against the block's Merkle root.

Using this functionality of an SPV node as a building block, we examine how an SPV wallet according to BIP-37~\cite{bip37} can be built. The SPV wallet connects with the full node network. There, it establishes connection with some peer node. It then announces a bloom filter including the initial address generated by invoking $\text{KDF}(seed, 0)$ to the connected node via a \texttt{filterload} call. After that it starts invoking \texttt{getblock} calls to the peer, starting from the first block with transactions that may implicate the user's seed. If no such block is known, or the best tip block tip is not already known by other means, the first block is set to the genesis. For every block the peer returns, it scans each transaction for matches to the set bloom filter. To the wallet, the block header is sent along with the transactions. Finally for verification, a multi-element Merkle proof of inclusion (named Partial Merkle Tree in BIP-37) for all the matching transactions is also sent. The wallet repeats \texttt{getblock} calls until it reaches the blockchain tip. By that point and assuming an honest peer, the full transaction history is known, along with the balance, and new transactions can be successfully created.

%TODO: talk about incrementing the nonce
%TODO: talk about server-side bloom filter alteration

A well known implementation of BIP-37 SPV is included in the bitcoinj library~\cite{bitcoinj}, which is a full Bitcoin implementation in Java. The only well known SPV wallet in practice is based on that library and is Andreas Schildbach's Android Bitcoin wallet. Other applications that implement BIP-37 SPV wallets include BRD and OpenBazaar.

Note that the protocol may seem wasteful, especially in case the header chain is already synced as it forces us to re-download the whole header chain. Additionally, it may seem wasteful that the peer needs to process every single transaction in history in order to service the peer. These inefficiencies are mitigated in the next protocol we are going to discuss.

%TODO: talk about how the server can withhold transactions

\subsection{Electrum}
%TODO: checkpoints
Electrum is probably the most well-known wallet for Bitcoin.
The protocol it utilizes is as follows. First, the wallet connects to 10 peers chosen from a hardcoded list in the software. One of them is selected as primary at random. The peers speak a protocol specified by Electrum and not the full node protocol.
In Electrum, servers hold an address index over all historical transactions. In early versions~\cite{electrumserver} of the server the index was arranged in a Merkle Patricia Trie~\cite{ultimate}. The most widely used server implementation~\cite{electrumserverrust} does not arranging the index in this way and simply relies on an underlying key-value store.

The wallet obtains all the header-chains advertised by its peers and verifies their Proof-of-Work. It then only keeps the heaviest valid chain for further processing. Subsequently it makes use of the \texttt{block\-chain.\allowbreak script\-hash.\allowbreak get\_history}
\footnote{The full API offered by an Electrum server is shown in \url{https://electrumx.readthedocs.io/en/latest/protocol-methods.html}}
API call to obtain all transactions concerning every possible address of the user, incrementing the KDF nonce until no more transactions are found. For each of these transactions it requires a Merkle proof of inclusion that is valid against some block in the heaviest chain.

We remark that the Electrum protocol is more efficient than the previous SPV wallet solution. Unfortunately, this comes at the cost of directly revealing the user's addresses to the remote peer. An Electrum server customarily maintains an address index for all historical transactions, making servicing the \texttt{get\_history} very efficient, in contrast with the heavy work a full node has to do to service an SPV wallet.
\subsection{Neutrino}
Neutrino is a new proposal for more efficient light syncing on Bitcoin which aims to be an improvement over SPV. Initially proposed for Lightning, it provides a nice solution for light wallets. It is described in BIP-157, BIP-158.

Neutrino requires a consensus change or soft fork, yet to occur for Bitcoin. With this change, in every block a small bytearray is included which represents information about the block's transactions. Specifically, the bytearray which is called the \emph{filter} is a Golomb-Coded Set~\cite{golomb1966run}
which encodes the set of all output scripts and the scripts of the outputs the inputs spend (except \texttt{OP\_RETURN}s for technical reasons).

With this filter in place the light wallet works as follows. Initially, it downloads all block headers as usual and verifies them. Then it proceeds to download the filter corresponding to each block. It then checks locally for every block if it contains transactions of interest by making use of the filter. If a block contains transactions of interest, all its transactions are requested without witness data (e.g. signatures and data belonging to unlocking scripts). Then from the transactions obtained the wallet can only keep the actual transactions of interest and discard the rest.

The improvements over SPV are twofold:
\paragraph{Privacy.} In an SPV wallet, the transactions of interest to the wallet are directly leaked to the peer, except with some relative deniability due to the bloom filter's false positive rate. Due to the low false positive rate of a bloom filter and the widely known transaction linking heuristics that can be applied~\cite{meiklejohn2013fistful,gervais2014privacy}
the peer can be almost certain which transactions belong to the same entity, breaking the pseudonymity of Bitcoin.
\paragraph{Server performance.} Observe how in Neutrino the server does no special computation for each client in contrast with an SPV server. In Neutrino servers are essentially relays of information, which is much cheaper and makes it more appealing to operators to operate them.
\paragraph{Client performance.} Additionally in contrast with SPV, if the wallet happens to hold the header-chain through some means, it can just obtain the filters without the need to redownload the already downloaded headers as is the case with SPV.

However these improvements come at the cost of bandwidth. For each block its corresponding filter must be downloaded to detect relevant transactions in that block. The filter size for a 1.4MB block is approximately 20KB~\cite{jimmysong}. This is a significant overhead compared to SPV, where no such filter needs to be downloaded.

Neutrino is currently implemented in the bchd full node~\cite{bchd}, giving an easy option to any bchd full node to act as a Neutrino server if they so desire.

The homonymous Neutrino wallet for Android is the only known client implementation.

\subsection{Yoroi}
Yoroi is Cardano's most widely used wallet. It does not connect to full nodes or peers that relay block headers, only to a blockchain explorer. It requests the user's transactions from the explorer, but does not verify that the transactions are all included in blocks in the best chain. From them the wallet determines the UTXO set and can thus fund transaction descriptions, compute the balance and show the transaction history. Since no transaction verification is taking place, the explorer is a trusted third party.

Most wallets that have seen wide use follow Yoroi's model, including Exodus. Additionally, the apps that utilize hardware wallets like Ledger and Trezor work in this manner.

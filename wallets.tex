%\documentclass[sigconf,authordraft]{acmart}
\documentclass[sigconf]{acmart}
\usepackage[capitalise]{cleveref}
\usepackage{adjustbox}
\usepackage{array}
\hyphenation{block-chain block-chains}
\hyphenation{side-chain side-chains}
\hyphenation{cryp-to-cur-ren-cy cryp-to-cur-ren-cies}
\hyphenation{bit-coin bit-coins}
\hyphenation{ethe-re-um}
\hyphenation{mo-ne-ro}
\hyphenation{dec-red}
\hyphenation{poly-no-mi-al}

\begin{document}

\title{A Taxonomy of Cryptocurrency Wallets}

\author{Kostis Karantias}
\affiliation{\institution{IOHK}}
\email{kostis.karantias@iohk.io}

\renewcommand{\shortauthors}{Karantias}

\begin{abstract}
    The primary function of a cryptocurrency is money transfer between individuals. The \emph{wallet} is the software that facilitates such transfers. Wallets are nowadays ubiquitous in the cryptocurrency space and a cryptocurrency is usually supported by many wallets. Despite that, the functionality of wallets has never been formally defined. Additionally, the mechanisms employed by the many wallets in the wild remain hidden in their respective codebases.
    
    In this work we provide the first definition of a cryptocurrency wallet. We provide a distinction of wallets in various categories, based on their whether they work for transparent or private cryptocurrencies, what trust assumptions they require, their performance and their communication overhead. For each type of wallet we provide a pseudocode implementation. Additionally, we explore the \emph{light wallets} and describe their difference to \emph{light clients} that have appeared in recent literature. Finally, we prove that light wallets are infeasible in private cryptocurrencies like ZCash.
\end{abstract}

\maketitle

\section{Introduction}
Along with the introduction of cryptocurrency in the form of Bitcoin~\cite{bitcoin}, the wallet was introduced as the primary way to interact with the cryptocurrency.

Usability is one of the most important obstacles in the adoption of cryptocurrencies~\cite{meiklejohn2018top}.

In this work, we:
\begin{itemize}
    \item Define what a wallet is.
    \item Provide detailed descriptions of how wallets in practice work for both transparent and private blockchains.
    \item Compare the wallets based on their attributes: performance, trust model, functionality offered.
\end{itemize}

\section{Definitions}
\begin{definition}
    A cryptocurrency wallet $W_\text{seed}$ is a pair of algorithms (\textsf{Sync}, \textsf{History}, \textsf{Spend}).
    
    $\mathsf{Sync}(\text{state}) \rightarrow \text{state}'$: Takes a user's cryptocurrency seed and the wallet state$'$ and produces a new wallet state' after interacting with network participants. We denote the initial state as $\varepsilon$.
    
    $\mathsf{History}(\text{state}) \rightarrow 2^\textsc{TXs}$: Returns the transaction history for the wallet seed.
    
    $\mathsf{Spend}(\text{state}, \text{txDescription}) \rightarrow \text{tx}$: Takes a transaction description txDescription and returns a valid transaction tx that spends from funds owned by the wallet's seed.
\end{definition}

\paragraph{Computational Complexity.} Computation to restore from a seed.
\paragraph{Communication Complexity.} Bandwidth to restore from a seed.
\paragraph{Privacy.} Do we disclose any private key to an external participant or server?

\section{Functionality}
Intuitively, the wallet should offer 2 important functions. Given a seed and the ability of network interactions, it should present the user with:

\begin{itemize}
    \item Their balance.
    \item Their transaction history.
    \item The ability to create new valid transactions, given a description.
\end{itemize}

\subsection{UTXO-based}
For UTXO-based cryptocurrencies like Bitcoin, by knowing a seed's UTXO the wallet can know the balance and be able to create valid new transactions.

\subsection{Account-based}
For account-based cryptocurrencies like Ethereum, ...

\subsection{Privacy coins}

\section{Transparent Wallets}

In order to be functional in a UTXO-based cryptocurrency, the wallet needs to obtain the UTXO subset belonging to the user's seed. This will allow the user to know their balance and be able to create new transactions. In order to know their transaction history, the user must evaluate all transaction outputs in history to detect incoming payments and all transaction inputs to detect outgoing payments.

\subsection{Full Node}
%Full node wallets plug directly to a full node. The full node 
The best known example of a full node wallet is Bitcoin-Qt.

A full node contains in its state the complete chain with full blocks, that include all of their transactions. In addition, the chain is assumed to be verified for validity.

\paragraph{Transaction history \& Spending.}
When presented with a seed, the full node wallet starts evaluating all transactions in every block from genesis up to the tip to detect which ones implicate the user's seed. This process is linear in the chain size, henceforth $O(n)$.

\paragraph{Only Balance \& Spending (Pruned mode).}
When presented with a seed in pruned mode, a full node wallet can only evaluate all outputs in the UTXO to detect the user's current spendable balance. In this way, the transaction history is not known but new transactions can be generated without a problem. One shortcoming of this approach is the additional assumption that we know the maximum nonce in use with the user's seed. We must assume a maximum nonce in order to generate a list of possible addresses of the user and scan the UTXO for outputs directed to them.

If the UTXO is stored as a list, then every entry must be checked, which yields performance of $O(|utxo|)$. However, the UTXO can easily be indexed by address, which makes detection $O(maxnonce)$.
\subsection{SPV}
SPV was first described in the Bitcoin whitepaper~\cite{bitcoin}.
The idea is as follows, a light node only requests and holds the header chain, that is only the header part of each block (which in Bitcoin is 80 bytes) and not the full block. When someone wishes to prove a transaction took place to an SPV node, they need to provide (a) the transaction (b) the id of the block that contains it and (c) a Merkle proof of inclusion to the Merkle root included in said block. The SPV node can check that the claimed block is part of its local best header chain and the Merkle proof provided is valid against the block's Merkle root.

Using this functionality of an SPV node as a building block, we examine how an SPV wallet can be built. In Bitcoin an SPV wallet works as follows. The SPV wallet connects with the full node network. There, it establishes connection with some peer node. It then announces a bloom filter including the initial address generated by invoking $\text{KDF}(seed, 0)$ to the connected node via a \texttt{filterload} call. After that it starts invoking \texttt{getblock} calls to the peer, starting from the first block with transactions that may implicate the user's seed. If no such block is known, or the best tip block tip is not already known by other means, the first block is set to the genesis. For every block the peer returns, it scans each transaction for matches to the set bloom filter. To the wallet, the block header is sent along with the transactions. Finally for verification, a multi-element Merkle proof of inclusion (named Partial Merkle Tree in BIP-37) for all the matching transactions is also sent. The wallet repeats \texttt{getblock} calls until it reaches the blockchain tip. By that point and assuming an honest peer, the full transaction history is known, along with the balance, and new transactions can be successfully created.

%TODO: talk about incrementing the nonce
%TODO: talk about server-side bloom filter alteration

The only well known SPV wallet in practice is Andreas Schildbach's Android Bitcoin wallet.

Note that the protocol may seem wasteful, especially in case the header chain is already synced as it forces us to re-download the whole header chain. Additionally, it may seem wasteful that the peer needs to process every single transaction in history in order to service the peer. These inefficiencies are mitigated in the next protocol we are going to discuss.

%TODO: talk about how the server can withhold transactions

\subsection{Electrum}
%TODO: checkpoints
Electrum is probably the most well-known wallet for Bitcoin.
The protocol it utilizes is as follows. First, the wallet connects to 10 peers chosen from a hardcoded list in the software. One of them is selected as primary at random. The peers speak a protocol specified by Electrum and not the full node protocol.
In Electrum, servers hold an address index over all historical transactions. In early versions~\cite{electrumserver} of the server the index was arranged in a Merkle Patricia Trie~\cite{ultimate}. The most widely used server implementation~\cite{electrumserverrust} does not arranging the index in this way and simply relies on an underlying key-value store.

The wallet obtains all the header-chains advertised by its peers and verifies their Proof-of-Work. It then only keeps the heaviest valid chain for further processing. Subsequently it makes use of the \texttt{block\-chain.\allowbreak script\-hash.\allowbreak get\_history}
\footnote{The full API offered by an Electrum server is shown in \url{https://electrumx.readthedocs.io/en/latest/protocol-methods.html}}
API call to obtain all transactions concerning every possible address of the user, incrementing the KDF nonce until no more transactions are found. For each of these transactions it requires a Merkle proof of inclusion that is valid against some block in the heaviest chain.

We remark that the Electrum protocol is more efficient than the previous SPV wallet solution. Unfortunately, this comes at the cost of directly revealing the user's addresses to the remote peer. An Electrum server customarily maintains an address index for all historical transactions, making servicing the \texttt{get\_history} very efficient, in contrast with the heavy work a full node has to do to service an SPV wallet.
\subsection{Neutrino}
Neutrino is a new proposal for more efficient light syncing on Bitcoin which aims to be an improvement over SPV. Initially proposed for Lightning, it provides a nice solution for light wallets. It is described in BIP-157, BIP-158.

Neutrino requires a consensus change or soft fork, yet to occur for Bitcoin. With this change, in every block a small bytearray is included which represents information about the block's transactions. Specifically, the bytearray which is called the \emph{filter} is a Golomb-Coded Set~\cite{golomb1966run}
which encodes the set of all output scripts and the scripts of the outputs the inputs spend (except \texttt{OP\_RETURN}s for technical reasons).

With this filter in place the light wallet works as follows. Initially, it downloads all block headers as usual and verifies them. Then it proceeds to download the filter corresponding to each block. It then checks locally for every block if it contains transactions of interest by making use of the filter. If a block contains transactions of interest, all its transactions are requested without witness data (e.g. signatures and data belonging to unlocking scripts). Then from the transactions obtained the wallet can only keep the actual transactions of interest and discard the rest.

The improvements over SPV are twofold:
\paragraph{Privacy.} In an SPV wallet, the transactions of interest to the wallet are directly leaked to the peer, except with some relative deniability due to the bloom filter's false positive rate. Due to the low false positive rate of a bloom filter and the widely known transaction linking heuristics that can be applied~\cite{meiklejohn2013fistful,gervais2014privacy}
the peer can be almost certain which transactions belong to the same entity, breaking the pseudonymity of Bitcoin.
\paragraph{Server performance.} Observe how in Neutrino the server does no special computation for each client in contrast with an SPV server. In Neutrino servers are essentially relays of information, which is much cheaper and makes it more appealing to operators to operate them.
\paragraph{Client performance.} Additionally in contrast with SPV, if the wallet happens to hold the header-chain through some means, it can just obtain the filters without the need to redownload the already downloaded headers as is the case with SPV.

However these improvements come at the cost of bandwidth. For each block its corresponding filter must be downloaded to detect relevant transactions in that block. The filter size for a 1.4MB block is approximately 20KB~\cite{jimmysong}. This is a significant overhead compared to SPV, where no such filter needs to be downloaded.

Neutrino is currently implemented in the bchd full node~\cite{bchd}, giving an easy option to any bchd full node to act as a Neutrino server if they so desire.

The homonymous Neutrino wallet for Android is the only known client implementation.

\subsection{Metamask}
Metamask is Ethereum's most widely used wallet. It does not connect to full nodes or peers that relay block headers, only to a blockchain explorer. It requests the user's transactions from the explorer, but does not verify that the transactions are all included in blocks in the best chain. From them the wallet determines the necessary nonce by computing the number of outgoing transactions, which is all the information necessary in order to create valid new transactions. It also computes the balance and can show the transaction history. Since no transaction verification is taking place, the explorer is a trusted third party.

Most other wallets that have seen wide use follow Metamask's model, including Exodus, Yoroi and others. Additionally, the apps that utilize hardware wallets like Ledger and Trezor work in this manner.

\section{Privacy Wallets}
In this section we will discuss wallets for ZCash, one of the most prominent private cryptocurrencies.

We first examine the requirements for a ZCash wallet to be functional. To create a new transaction sending funds to some party, the wallet needs to know the unspent outputs belonging to the user. From these outputs the amount and some auxillary values must be discovered, in order to allow the wallet to create a nullifier for the commitment and spend it. In order to create a valid transaction with a valid Zero Knowledge proof the wallet also needs to know the full contents of the commitment tree, to prove that they are spending a commitment included in that tree.

\subsection{Full Node}
The full node wallet works in a straightforward manner. All blocks and transactions are assumed to be already downloaded and verified locally. Upon being presented with a seed, the wallet evaluates every transaction from the genesis up to the tip for relevance. Outputs to the shielded address are decryptable by the secret key corresponding to that shielded address.

When evaluating an output, it may be directed to a shielded address of the user. In that case we store the commitment and private values of the output. When evaluating an input, it may be that the user has spent a previous commentment, in which case we mark the commitment as spent. Additionally for every input and output we store the transaction to display to the user.

Finally, we end up with a set of unspent commitments along with their private values. Given a transaction description the wallet can then spend any of those unspent commitments.

\subsection{SPV}
SPV nodes for private cryptocurrencies don't exist in practice due to the detection problem. Private cryptocurrencies are designed to make it hard to detect receivers of transactions. Thus a helpful server who has the chain that is able to detect transactions on account of a user is orthogonal to the design of the cryptocurrency.

A hypothetical SPV wallet however, could avoid performing verification of the chain contents (the transactions) and only perform verification of the header-chain. While this does not reduce the bandwidth requirements of an SPV wallet, it could significantly reduce the computation time for syncing. This is especially important in the case of ZCash where verifying the validity of a zero-knowledge proof of a transaction may take time in the order of milliseconds.

\subsubsection{Compact Blocks}
In ZIP-307 an optimization for bandwidth is proposed. The optimization lies in noticing that since under the assumption of SPV security transactions don't need to be verified, transactions only need to hold the minimum amount of data such that they are detectable. By only keeping this data, transactions are compressed. Block headers remain unchanged. The new block structure including these compressed transactions is dubbed a compact block.

This is a backwards-compatible change to the ZCash network that does not require any consensus changes. Blocks are adapted to this compact block format by any interested server and are subsequently relayed to any clients that request them.

If a client detects an inbound or outgoing payment of interest, it can then request the full transaction from the server.
%TODO: what can a server do?

This compression of the transactions is lossy and means that the transactions inclusion in the claimed block header can't be verified via a Merkle proof in the same way it can be verified on transparent SPV. This is because the hash of the original transaction cannot be reproduced unless the full transaction is owned, which defeats the purpose. However, a similar verification can be performed as follows. Every shielded output references a new commitment. ZCash in its block header includes a Merkle Tree root of the existing commitment set after adding all commitments the transactions of the block itself create. Thus even though transactions themselves cannot be verified as valid, shielded outputs can by verifying a Merkle inclusion proof of inclusion of the commitment in the Merkle Tree root of commitments. For the inputs no processing needs to be done. If an input reveals a note belonging to the user then this note can be marked as spent as the only person who would be able to reveal the note is the user itself and it can't be faked by any server. If an input reveals a note belonging to someone else the server has nothing to gain by tricking the wallet into thinking it is revealed in a block where it is not. Cases of double-spending by an adversarial server are completely thwarted by the output verification.

We remark that this is not an asymptotic improvement over the theoretical SPV solution. We posit that an asymptotic improvement over the theoretical SPV solution which preserves privacy (i.e. no private keys are revealed to the remote peer) cannot exist.
\subsection{MyMonero}
A final solution for private cryptocurrencies observed in practice comes from Monero. MyMonero is a desktop and mobile wallet that operates with the help of a trusted server. The viewing private key is disclosed to the server so that it can detect transactions on the wallet's behalf. Any detected transactions are relayed to the wallet in order for the wallet to display and for the wallet to hold an up-to-date UTXO for the purposes of creating new transactions.

MyMonero works differently when the user creates a new seed and when the user recovers their wallet with an existing seed. When creating a new seed, the viewing private key is disclosed but because the server knows the key was just generated they can be certain that it has never received any transactions.

In the case of recovering from an existing seed there are two cases. Either the server already knows the corresponding viewing private key, in which case it can directly relay the transactions it knows, or the key is presented to the server for the first time. If the latter case holds, the server will take on the difficult task of looking through each transaction from the genesis up to the tip in order to detect transactions sent to the user. However, because of the computational difficulty of the task, it will request that the user pledges to send back a small reward for the server in the form of Monero before starting.
%TODO: explain how

The server is a full-node that maintains the whole chain and its tip. Only when a client requests their transactions it scans the blocks starting from the last processed block for the requested viewing key up until the tip.

\section{Double-spend attacks}
\section{Finney attacks}

\section{Comparison}
\newcolumntype{R}[2]{%
    >{\adjustbox{angle=#1,lap=\width-(#2)}\bgroup}%
    l%
    <{\egroup}%
}
\newcommand*\rot{\multicolumn{1}{R{45}{1em}}}% no optional argument here, please!

\def\half{\char9680}
\def\full{\char9679}

\begin{table*}
\caption{A comparison of the cryptocurrency wallets in practice. Server computation only refers to the computation the server is required to do to serve a new wallet and does not include previous or continuous computation like maintaining an address index. Partial vulnerability to an attack is denoted with \half{} and full vulnerability is denoted with \full.\label{comparison}}
\centering
\begin{tabular}{|r|ccc|cccc|}
\multicolumn{1}{c}{} &
\rot{Bandwidth} &
\rot{Client computation} &
\rot{Server computation*} &
\rot{Open participation} &
\rot{Address leakage} &
\rot{Double-spendable} &
\rot{Invalid tx acceptance}
\\ \hline
\emph{Proposal}&\multicolumn{3}{c|}{\emph{Performance}}&\multicolumn{4}{c|}{\emph{Security}} \\
\hline
%name    &bandwidt&client  &server  &open &leak &doubl&inval
Full Node&$O(n+m)$&$O(n+m)$&$O(1)$  &\full&     &     &     \\
SPV      &$O(n+y)$&$O(n+y)$&$O(n+m)$&\full&\half&     &     \\
Electrum &$O(n+y)$&$O(n+y)$&$O(1)$  &     &\full&     &     \\
Neutrino &$O(n+y)$&$O(n+y)$&$O(1)$  &\full&\half&     &     \\
Metamask &$O(y)$  &$O(1)$  &$O(1)$  &     &\full&\full&\full\\
\hline
\end{tabular}
\end{table*}

A comparison of the wallets can be seen in \cref{comparison}.

\section{From Light Clients to Light Wallets}

\begin{acks}
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{refs}

\appendix

\section{Appendix Section 1}

\end{document}
\endinput
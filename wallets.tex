\documentclass[sigconf,authordraft]{acmart}
%\documentclass[sigconf]{acmart}
\usepackage{algorithm}
\usepackage{algpseudocode}
\algrenewcommand\textproc{} % disable textsc on function names
\usepackage[capitalise]{cleveref}
\usepackage{adjustbox}
\usepackage{array}
\usepackage[htt]{hyphenat}
\hyphenation{block-chain block-chains}
\hyphenation{side-chain side-chains}
\hyphenation{cryp-to-cur-ren-cy cryp-to-cur-ren-cies}
\hyphenation{bit-coin bit-coins}
\hyphenation{ethe-re-um}
\hyphenation{mo-ne-ro}
\hyphenation{dec-red}
\hyphenation{poly-no-mi-al}
\hyphenation{Mer-kle}
\newcommand{\pluseq}{\texttt{\,+=\,}}
\newcommand{\minuseq}{\texttt{\,-=\,}}
\newcommand{\stareq}{\texttt{\,*=\,}}
\newcommand{\slasheq}{\texttt{\,/=\,}}
\newcommand{\plusplus}{\texttt{++}}
\newcommand{\cupeq}{\texttt{\,$\cup$=\,}}

\usepackage{fontspec}
\setmonofont[
  Scale=MatchLowercase,
  FakeStretch=0.85,
]{DejaVu Sans Mono}
\newfontface{\freeserif}{FreeSerif}

\begin{document}

\title{A Taxonomy of Cryptocurrency Wallets}

\author{Kostis Karantias}
\affiliation{\institution{IOHK}}
\email{kostis.karantias@iohk.io}

\renewcommand{\shortauthors}{Karantias}

\begin{abstract}
    The primary function of a cryptocurrency is money transfer between individuals. The \emph{wallet} is the software that facilitates such transfers. Wallets are nowadays ubiquitous in the cryptocurrency space and a cryptocurrency is usually supported by many wallets. Despite that, the functionality of wallets has never been formally defined. Additionally, the mechanisms employed by the many wallets in the wild remain hidden in their respective codebases.
    
    In this work we provide the first definition of a cryptocurrency wallet. We provide a distinction of wallets in various categories, based on their whether they work for transparent or private cryptocurrencies, what trust assumptions they require, their performance and their communication overhead. For each type of wallet we provide a pseudocode implementation. Additionally, we explore the \emph{light wallets} and describe their difference to \emph{light clients} that have appeared in recent literature. Finally, we prove that light wallets are infeasible in private cryptocurrencies like ZCash.
\end{abstract}

\maketitle

\section{Introduction}
Along with the introduction of cryptocurrency in the form of Bitcoin~\cite{bitcoin}, the wallet was introduced as the primary way to interact with the cryptocurrency.

Usability is one of the most important obstacles in the adoption of cryptocurrencies~\cite{meiklejohn2018top}.

\paragraph{Our contributions.} In this work, we:
\begin{itemize}
    \item Define the purpose of a cryptocurrency wallet: to create and broadcast valid transactions, to know the balance and to know the transaction history.
    \item Provide detailed descriptions of how wallets in practice work for both transparent and private blockchains.
    \item Compare the known wallet protocols on their performance and security characteristics.
    \item Define for the first time the functionality of light clients, which are commonly conflated with light wallets.
    \item Provide a construction for light wallets based on a light client.
\end{itemize}

\section{Definitions}
\begin{definition}
    A cryptocurrency wallet $W_\text{seed}$ is a pair of algorithms (\textsf{Sync}, \textsf{History}, \textsf{Spend}).
    
    $\mathsf{Sync}(\text{state}) \rightarrow \text{state}'$: Takes a user's cryptocurrency seed and the wallet state$'$ and produces a new wallet state' after interacting with network participants. We denote the initial state as $\varepsilon$.
    
    $\mathsf{History}(\text{state}) \rightarrow 2^\textsc{TXs}$: Returns the transaction history for the wallet seed.
    
    $\mathsf{Spend}(\text{state}, \text{txDescription}) \rightarrow \text{tx}$: Takes a transaction description txDescription and returns a valid transaction tx that spends from funds owned by the wallet's seed.
\end{definition}

\paragraph{Computational Complexity.} Computation to restore from a seed.
\paragraph{Communication Complexity.} Bandwidth to restore from a seed.
\paragraph{Privacy.} Do we disclose any private key to an external participant or server?

\section{Preliminaries}
\subsection{The UTXO Model}
In the UTXO model a transaction consists of inputs and outputs. An output consists of an amount and a locking script (called \texttt{scriptPubKey} in Bitcoin). In Bitcoin the locking script is described in a stack-based language called Bitcoin Script. An input consists of an unlocking script (called \texttt{scriptSig} in Bitcoin) and an output pointer (also called an outpoint) which is a tuple of the form (\texttt{txID}, \texttt{outputIndex}). We say that an input \emph{spends} an output, where \texttt{txID} refers to the transaction id that includes the output and \texttt{outputIndex} refers to the zero-based index of the output to be spent in that transaction.

\def\btcstate{\sigma_\text{btc}}
\def\btcapply{\text{apply}\textsubscript{btc}}
\def\outputs{\texttt{outputs}}
\def\inputs{\texttt{inputs}}
\def\spentOutputs{\texttt{spentOutputs}}
\def\utxo{\texttt{utxo}}
The global state of UTXO based cryptocurrencies includes all transaction outputs, and all spent transaction outputs. UTXO stands for unspent transaction outputs, which can trivially be computed from this state as $\btcstate.\utxo \triangleq \btcstate.\outputs \setminus \btcstate.\spentOutputs$.

An input is valid with regards to a state $\btcstate$ if (a) the output it references exists (i.e. $\in \btcstate.\outputs$) and is not already spent (i.e. $\notin \btcstate.\spentOutputs$) and (b) the unlocking script of the input ``unlocks'' the locking script of the output. In the case of Bitcoin, the unlocking script runs on an empty stack, and subsequently the locking script runs on the resulting stack of the unlocking script's execution. The input is considered to unlock the output if the locking script terminates successfully.

The transaction as a whole is valid if all inputs are valid and the sum of the values generated by its outputs is at most the sum of the values brought in by its inputs. The fee is defined as the absolute difference between the two sums. The state can be updated by a valid transaction as shown in \cref{alg.btcapply}, where the new outputs are added and newly spent outputs are marked as such.

The most usual form of output is Pay-to-Public-Key-Hash (P2PKH), which as its name implies includes the public key hash of the recipient. For an input spending it to be valid, it needs to contain a signature of the corresponding secret key over the new transaction skeleton and the output to be spent.

Money generation happens with coinbase transactions. A coinbase transaction is a special exception of a transaction that provides miners (in Proof-of-Work based cryptocurrencies) or minters (in Proof-of-Stake based cryptocurrencies) with their reward. Each block may have a single coinbase transaction. The coinbase transaction contains no inputs and generates only as much value as is considered the block reward per the consensus rules, plus any transaction fees.

\begin{algorithm}[H]
    \caption{\label{alg.btcapply} The $\btcapply$ function given a state $\btcstate$ and a transaction $tx$.}
    \begin{algorithmic}[1]
        \Function{$\btcapply$}{$\btcstate, tx$}
            \For{$o \in tx.\outputs$}
                \State{$\btcstate.\outputs \cupeq \{o\}$}
            \EndFor
            \For{$i \in tx.\inputs$}
                \State{$\btcstate.\spentOutputs \cupeq \{i.\texttt{output}\}$}
            \EndFor
            \State\Return{$\btcstate$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\subsection{The Account Model}
In the account model, a transfer transaction consists of a sender, a receiver, an amount, a nonce, a fee and a signature. The sender and receiver are public keys. The fee acts as an additional miner reward as in the UTXO model.

\def\state{\text{state}}
\def\chain{\mathcal{C}}
\def\sender{\texttt{sender}}
\def\receiver{\texttt{receiver}}
\def\amount{\texttt{amount}}
\def\fee{\texttt{fee}}
\def\nonce{\text{nonce}}
\def\bal{\text{balance}}
\def\ethstate{\sigma_\text{eth}}
For a transfer transaction to be valid with respect to a state $\ethstate$, the following conditions need to hold. We assume a function $\state(\chain)$ that returns the state of the world according to $\chain$. With $\ethstate[\texttt{address}]$ we denote the state of the account with the specified address.

\begin{itemize}
    \item The signature must be valid and generated by the secret key of the sender over the rest of the transfer transaction.
    \item The nonce must be equal to $\ethstate[\sender].\nonce + 1$.
    \item The sender must have adequate balance.
    \[
        \ethstate[\sender].\bal \ge \amount+\fee
    \]
\end{itemize}

We remark that the nonce is necessary in order to avoid replay attacks, for if it was absent some receiver would be able to repeat the same transaction ad infinitum until the sender account is completely drained. Note that a potential solution to this would be to maintain a set of processed transaction ids and add a requirement that the transaction to be evaluated for validity does not belong in that set. If the sender ever wishes to send the same amount to the same recipient, they will need to generate a new signature and thus the transaction will have a different transaction id. In theory this solution stands, however in practice due to the malleability of ECDSA a signature can be modified in a way that it changes and consequently the transaction id changes, while retaining its validity.

\def\ethapply{\text{apply}\textsubscript{eth}}

A valid transaction according to a state can be applied to it to generate a new state. We perform this state transformation with a function $\ethapply(\ethstate, tx)$ which debits the receiver, credits the sender and increments the sender's nonce. The full definition of $\ethapply$ is given in \cref{alg.ethapply}.

\begin{algorithm}[H]
    \caption{\label{alg.ethapply} The $\ethapply$ function given a $\ethstate$ and a transaction.}
    \begin{algorithmic}[1]
        \Function{$\ethapply$}{$\ethstate, tx$}
            \State{$\plusplus\ethstate[tx.\sender].\nonce$}
            \State{$\ethstate[tx.\sender].\bal \minuseq tx.\amount$}
            \State{$\ethstate[tx.\receiver].\bal \pluseq tx.\amount$}
            \State\Return{$\ethstate$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

Coinbase transactions could exist in account-based cryptocurrencies, for example having a $\sender$ field of all zeros. In practice Ethereum-based cryptocurrencies don't have them but instead directly include the miner's address inside the block header. For our purposes we will not consider the change of state due to miner rewards.

\subsection{SPV Security}
\begin{definition}[SPV client]
An \emph{SPV client} is an ITM that knows a genesis block \textsf{Gen} connects to a set of full nodes $\mathcal{P}$, at least one of which is honest. It may only request block headers at a range of heights. It obtains all header-chains $\chain_1, \dots, \chain_{|\mathcal{P}|}$, keeping only those for which the chain structure holds ($\forall 1 < i \le |\chain|: H(\chain[i-1]) = \chain[i].previd$). It subsequently compares them and adopts the chain with the most difficulty.
\end{definition}

We state some theorems pertaining to the adopted chain of an SPV client which are derivable from the works of~\cite{backbone,garay2017bitcoin,pass2017analysis}.

\begin{definition}[Honest majority assumption]
The adversarial mining power is at all times upper bounded by the half of the total mining power of the network.
\end{definition}

\begin{theorem}[SPV security]
Under the honest majority assumption, the stable part of an SPV client's adopted chain $\chain[:-k]$ is a prefix of the chain of the honest full node.
\end{theorem}

\begin{corollary}
Under the honest majority assumption, the underlying full chain of the stable part of an SPV client's adopted chain is syntactically valid.
\end{corollary}

\section{Functionality}
Intuitively, the wallet should offer three important functions. Given a seed and the ability of network interactions, it should present the user with:

\begin{enumerate}
    \item Their balance.
    \item Their transaction history.
    \item The ability to create new valid transactions, given a description.
\end{enumerate}

\section{Transparent UTXO-based Wallets}

A transaction description specifies the desired outputs of a transaction and a fee. In the simplest case of sending some funds to a specific address, the transaction description is comprised of a single P2PKH output.

A wallet needs to be able to turn a transaction description into a valid transaction that will be accepted by full nodes in a process called funding. To fund a transaction description, the wallet performs the following steps:

\begin{itemize}
    \item Collect a set $S$ of unspent transaction outputs spendable by public keys derivable from the seed such that $$\sum_{o \in S} o.\text{value} \ge \textsf{value}$$
    \item Create a change output directed back to a public key derivable by the seed such that
    $$\sum_{input} input.\text{value} - \sum_{output} output.\text{value} = \textsf{fee}$$
    \item For each unspent transaction output in $S$, generate its unlocking script and use it as an input. In the typical case the unlocking script includes the signature of said transaction with the secret key of said output recipient.
\end{itemize}

The balance of a wallet can be obtained as the sum of the values of all unspent outputs destined to public keys derivable from the seed.

The transaction history of a wallet can be extracted from the set of all transactions implicating public keys derivable from the seed. Specifically, inputs where are spent by some private key derivable from the seed are debits, and outputs which are directed to some public key derivable from the seed are credits.

\subsection{Full Node}
%Full node wallets plug directly to a full node. The full node 
The best known example of a full node wallet is Bitcoin-Qt.

A full node contains in its state the complete chain with full blocks, that include all of their transactions. In addition, the chain is assumed to be verified for validity.

\paragraph{Transaction history \& Spending.}
When presented with a seed, the full node wallet starts evaluating all transactions in every block from genesis up to the tip to detect which ones implicate the user's seed. This process is linear in the chain size, henceforth $O(n)$.

\paragraph{Only Balance \& Spending (Pruned mode).}
When presented with a seed in pruned mode, a full node wallet can only evaluate all outputs in the UTXO to detect the user's current spendable balance. In this way, the transaction history is not known but new transactions can be generated without a problem. One shortcoming of this approach is the additional assumption that we know the maximum nonce in use with the user's seed. We must assume a maximum nonce in order to generate a list of possible addresses of the user and scan the UTXO for outputs directed to them.

If the UTXO is stored as a list, then every entry must be checked, which yields performance of $O(|utxo|)$. However, the UTXO can easily be indexed by address, which makes detection $O(maxnonce)$.
\subsection{BIP-37 SPV}
SPV was first described in the Bitcoin whitepaper~\cite{bitcoin}.
The idea is as follows, a light node only requests and holds the header chain, that is only the header part of each block (which in Bitcoin is 80 bytes) and not the full block. When someone wishes to prove a transaction took place to an SPV node, they need to provide (a) the transaction (b) the id of the block that contains it and (c) a Merkle proof of inclusion to the Merkle root included in said block. The SPV node can check that the claimed block is part of its local best header chain and the Merkle proof provided is valid against the block's Merkle root.

Using this functionality of an SPV node as a building block, we examine how an SPV wallet according to BIP-37~\cite{bip37} can be built. The SPV wallet connects with the full node network. There, it establishes connection with some peer node. It then announces a bloom filter including the initial address generated by invoking $\text{KDF}(seed, 0)$ to the connected node via a \texttt{filterload} call. After that it starts invoking \texttt{getblock} calls to the peer, starting from the first block with transactions that may implicate the user's seed. If no such block is known, or the best tip block tip is not already known by other means, the first block is set to the genesis. For every block the peer returns, it scans each transaction for matches to the set bloom filter. To the wallet, the block header is sent along with the transactions. Finally for verification, a multi-element Merkle proof of inclusion (named Partial Merkle Tree in BIP-37) for all the matching transactions is also sent. The wallet repeats \texttt{getblock} calls until it reaches the blockchain tip. By that point and assuming an honest peer, the full transaction history is known, along with the balance, and new transactions can be successfully created.

%TODO: talk about incrementing the nonce
%TODO: talk about server-side bloom filter alteration

A well known implementation of BIP-37 SPV is included in the bitcoinj library~\cite{bitcoinj}, which is a full Bitcoin implementation in Java. The only well known SPV wallet in practice is based on that library and is Andreas Schildbach's Android Bitcoin wallet. Other applications that implement BIP-37 SPV wallets include BRD and OpenBazaar.

Note that the protocol may seem wasteful, especially in case the header chain is already synced as it forces us to re-download the whole header chain. Additionally, it may seem wasteful that the peer needs to process every single transaction in history in order to service the peer. These inefficiencies are mitigated in the next protocol we are going to discuss.

%TODO: talk about how the server can withhold transactions

\subsection{Electrum}
%TODO: checkpoints
Electrum is probably the most well-known wallet for Bitcoin.
The protocol it utilizes is as follows. First, the wallet connects to 10 peers chosen from a hardcoded list in the software. One of them is selected as primary at random. The peers speak a protocol specified by Electrum and not the full node protocol.
In Electrum, servers hold an address index over all historical transactions. In early versions~\cite{electrumserver} of the server the index was arranged in a Merkle Patricia Trie~\cite{ultimate}. The most widely used server implementation~\cite{electrumserverrust} does not arranging the index in this way and simply relies on an underlying key-value store.

The wallet obtains all the header-chains advertised by its peers and verifies their Proof-of-Work. It then only keeps the heaviest valid chain for further processing. Subsequently it makes use of the \texttt{block\-chain.\allowbreak script\-hash.\allowbreak get\_history}
\footnote{The full API offered by an Electrum server is shown in \url{https://electrumx.readthedocs.io/en/latest/protocol-methods.html}}
API call to obtain all transactions concerning every possible address of the user, incrementing the KDF nonce until no more transactions are found. For each of these transactions it requires a Merkle proof of inclusion that is valid against some block in the heaviest chain.

We remark that the Electrum protocol is more efficient than the previous SPV wallet solution. Unfortunately, this comes at the cost of directly revealing the user's addresses to the remote peer. An Electrum server customarily maintains an address index for all historical transactions, making servicing the \texttt{get\_history} very efficient, in contrast with the heavy work a full node has to do to service an SPV wallet.
\subsection{Neutrino}
Neutrino is a new proposal for more efficient light syncing on Bitcoin which aims to be an improvement over SPV. Initially proposed for Lightning, it provides a nice solution for light wallets. It is described in BIP-157, BIP-158.

Neutrino requires a consensus change or soft fork, yet to occur for Bitcoin. With this change, in every block a small bytearray is included which represents information about the block's transactions. Specifically, the bytearray which is called the \emph{filter} is a Golomb-Coded Set~\cite{golomb1966run}
which encodes the set of all output scripts and the scripts of the outputs the inputs spend (except \texttt{OP\_RETURN}s for technical reasons).

With this filter in place the light wallet works as follows. Initially, it downloads all block headers as usual and verifies them. Then it proceeds to download the filter corresponding to each block. It then checks locally for every block if it contains transactions of interest by making use of the filter. If a block contains transactions of interest, all its transactions are requested without witness data (e.g. signatures and data belonging to unlocking scripts). Then from the transactions obtained the wallet can only keep the actual transactions of interest and discard the rest.

The improvements over SPV are twofold:
\paragraph{Privacy.} In an SPV wallet, the transactions of interest to the wallet are directly leaked to the peer, except with some relative deniability due to the bloom filter's false positive rate. Due to the low false positive rate of a bloom filter and the widely known transaction linking heuristics that can be applied~\cite{meiklejohn2013fistful,gervais2014privacy}
the peer can be almost certain which transactions belong to the same entity, breaking the pseudonymity of Bitcoin.
\paragraph{Server performance.} Observe how in Neutrino the server does no special computation for each client in contrast with an SPV server. In Neutrino servers are essentially relays of information, which is much cheaper and makes it more appealing to operators to operate them.
\paragraph{Client performance.} Additionally in contrast with SPV, if the wallet happens to hold the header-chain through some means, it can just obtain the filters without the need to redownload the already downloaded headers as is the case with SPV.

However these improvements come at the cost of bandwidth. For each block its corresponding filter must be downloaded to detect relevant transactions in that block. The filter size for a 1.4MB block is approximately 20KB~\cite{jimmysong}. This is a significant overhead compared to SPV, where no such filter needs to be downloaded.

Neutrino is currently implemented in the bchd full node~\cite{bchd}, giving an easy option to any bchd full node to act as a Neutrino server if they so desire.

The homonymous Neutrino wallet for Android is the only known client implementation.

\subsection{Yoroi}
Yoroi is Cardano's most widely used wallet. It does not connect to full nodes or peers that relay block headers, only to a blockchain explorer. It requests the user's transactions from the explorer, but does not verify that the transactions are all included in blocks in the best chain. From them the wallet determines the UTXO set and can thus fund transaction descriptions, compute the balance and show the transaction history. Since no transaction verification is taking place, the explorer is a trusted third party.

Most wallets that have seen wide use follow Yoroi's model, including Exodus. Additionally, the apps that utilize hardware wallets like Ledger and Trezor work in this manner.

\section{Privacy Wallets}
In this section we will discuss wallets for ZCash, one of the most prominent private cryptocurrencies.

We first examine the requirements for a ZCash wallet to be functional. To create a new transaction sending funds to some party, the wallet needs to know the unspent outputs belonging to the user. From these outputs the amount and some auxillary values must be discovered, in order to allow the wallet to create a nullifier for the commitment and spend it. In order to create a valid transaction with a valid Zero Knowledge proof the wallet also needs to know the full contents of the commitment tree, to prove that they are spending a commitment included in that tree.

\subsection{Full Node}
The full node wallet works in a straightforward manner. All blocks and transactions are assumed to be already downloaded and verified locally. Upon being presented with a seed, the wallet evaluates every transaction from the genesis up to the tip for relevance. Outputs to the shielded address are decryptable by the secret key corresponding to that shielded address.

When evaluating an output, it may be directed to a shielded address of the user. In that case we store the commitment and private values of the output. When evaluating an input, it may be that the user has spent a previous commentment, in which case we mark the commitment as spent. Additionally for every input and output we store the transaction to display to the user.

Finally, we end up with a set of unspent commitments along with their private values. Given a transaction description the wallet can then spend any of those unspent commitments.

\subsection{SPV}
SPV nodes for private cryptocurrencies don't exist in practice due to the detection problem. Private cryptocurrencies are designed to make it hard to detect receivers of transactions. Thus a helpful server who has the chain that is able to detect transactions on account of a user is orthogonal to the design of the cryptocurrency.

A hypothetical SPV wallet however, could avoid performing verification of the chain contents (the transactions) and only perform verification of the header-chain. While this does not reduce the bandwidth requirements of an SPV wallet, it could significantly reduce the computation time for syncing. This is especially important in the case of ZCash where verifying the validity of a zero-knowledge proof of a transaction may take time in the order of milliseconds.

\subsubsection{Compact Blocks}
In ZIP-307 an optimization for bandwidth is proposed. The optimization lies in noticing that since under the assumption of SPV security transactions don't need to be verified, transactions only need to hold the minimum amount of data such that they are detectable. By only keeping this data, transactions are compressed. Block headers remain unchanged. The new block structure including these compressed transactions is dubbed a compact block.

This is a backwards-compatible change to the ZCash network that does not require any consensus changes. Blocks are adapted to this compact block format by any interested server and are subsequently relayed to any clients that request them.

If a client detects an inbound or outgoing payment of interest, it can then request the full transaction from the server.
%TODO: what can a server do?

This compression of the transactions is lossy and means that the transactions inclusion in the claimed block header can't be verified via a Merkle proof in the same way it can be verified on transparent SPV. This is because the hash of the original transaction cannot be reproduced unless the full transaction is owned, which defeats the purpose. However, a similar verification can be performed as follows. Every shielded output references a new commitment. ZCash in its block header includes a Merkle Tree root of the existing commitment set after adding all commitments the transactions of the block itself create. Thus even though transactions themselves cannot be verified as valid, shielded outputs can by verifying a Merkle inclusion proof of inclusion of the commitment in the Merkle Tree root of commitments. For the inputs no processing needs to be done. If an input reveals a note belonging to the user then this note can be marked as spent as the only person who would be able to reveal the note is the user itself and it can't be faked by any server. If an input reveals a note belonging to someone else the server has nothing to gain by tricking the wallet into thinking it is revealed in a block where it is not. Cases of double-spending by an adversarial server are completely thwarted by the output verification.

We remark that this is not an asymptotic improvement over the theoretical SPV solution. We posit that an asymptotic improvement over the theoretical SPV solution which preserves privacy (i.e. no private keys are revealed to the remote peer) cannot exist.
\subsection{MyMonero}
A final solution for private cryptocurrencies observed in practice comes from Monero. MyMonero is a desktop and mobile wallet that operates with the help of a trusted server. The viewing private key is disclosed to the server so that it can detect transactions on the wallet's behalf. Any detected transactions are relayed to the wallet in order for the wallet to display and for the wallet to hold an up-to-date UTXO for the purposes of creating new transactions.

MyMonero works differently when the user creates a new seed and when the user recovers their wallet with an existing seed. When creating a new seed, the viewing private key is disclosed but because the server knows the key was just generated they can be certain that it has never received any transactions.

In the case of recovering from an existing seed there are two cases. Either the server already knows the corresponding viewing private key, in which case it can directly relay the transactions it knows, or the key is presented to the server for the first time. If the latter case holds, the server will take on the difficult task of looking through each transaction from the genesis up to the tip in order to detect transactions sent to the user. However, because of the computational difficulty of the task, it will request that the user pledges to send back a small reward for the server in the form of Monero before starting.
%TODO: explain how

The server is a full-node that maintains the whole chain and its tip. Only when a client requests their transactions it scans the blocks starting from the last processed block for the requested viewing key up until the tip.

\section{Attacks}
\subsection{Double-spend attacks}
\subsection{Finney attacks}

\section{Comparison}
\newcolumntype{R}[2]{%
    >{\adjustbox{angle=#1,lap=\width-(#2)}\bgroup}%
    l%
    <{\egroup}%
}
\newcommand*\rot{\multicolumn{1}{R{45}{1em}}}% no optional argument here, please!

\def\half{{\freeserif \char9680}}
\def\full{{\freeserif \char9679}}

\begin{table*}
\caption{A comparison of the cryptocurrency wallets in practice. Server computation only refers to the computation the server is required to do to serve a new wallet and does not include previous or continuous computation like maintaining an address index. Partial vulnerability to an attack is denoted with \half{} and full vulnerability is denoted with \full.\label{comparison}}
\centering
\begin{tabular}{|r|ccc|cccc|}
\multicolumn{1}{c}{} &
\rot{Bandwidth} &
\rot{Client computation} &
\rot{Server computation*} &
\rot{Open participation} &
\rot{Address leakage} &
\rot{Double-spendable} &
\rot{Invalid tx acceptance}
\\ \hline
\emph{Proposal}&\multicolumn{3}{c|}{\emph{Performance}}&\multicolumn{4}{c|}{\emph{Security}} \\
\hline
%name    &bandwidt&client  &server  &open &leak &doubl&inval
Full Node&$O(n+m)$&$O(n+m)$&$O(1)$  &\full&     &     &     \\
SPV      &$O(n+y)$&$O(n+y)$&$O(n+m)$&\full&\half&     &     \\
Electrum &$O(n+y)$&$O(n+y)$&$O(y)$  &     &\full&     &     \\
Neutrino &$O(n+y)$&$O(n+y)$&$O(1)$  &\full&\half&     &     \\
Yoroi    &$O(y)$  &$O(y)$  &$O(y)$  &     &\full&\full&\full\\
\hline
\end{tabular}
\end{table*}

We use the following variables for our asymptotic analysis:
\begin{itemize}
    \item $n$: number of all blocks
    \item $m$: number of all transaction
    \item $y$: number of relevant transactions (implicating the wallet user)
\end{itemize}

Our performance comparison is asymptotic in terms of the aforementioned variables and is broken down on the following aspects.

\begin{itemize}
    \item \textbf{Bandwidth}: The bandwidth necessary to fully synchronise a wallet from scratch.
    \item \textbf{Server computation}: Any computation necessary for the server to perform in order to aid the synchronisation of a new wallet.
    \item \textbf{Client computation}: Any computation it is necessary for the wallet to perform in order to finish synchronisation and enter a usable state (for funding transaction descriptions, balance and transaction history).
\end{itemize}

Our security comparison focuses on the following aspects.
\begin{itemize}
    \item \textbf{Open participation}: Whether participating as a wallet's server is possible for everyone.
    \item \textbf{Address leakage}: Whether the wallet reveals information about the user's addresses to any server in order to synchronise.
    \item \textbf{Double-spendable}: Whether any server can successfully mount a double-spend attack on the user through the wallet.
    \item \textbf{Invalid transaction acceptance}: Whether the wallet may accept transactions that are not part of the best chain.
\end{itemize}

A comparison of the wallets in tabular form is presented in \cref{comparison}.

\subsection{Full Node}
The full node requires the most amount of bandwidth, $O(n+m)$ as all full blocks must be downloaded. The amount of client computation is identical as every block and transaction needs to be verified. However, for servicing the full node other nodes need not perform any special computation and can simply act as relays. The network of a permisionless cryptocurrency's full node is open to participation by definition. No information pertaining to the wallet addresses can be produced by the network based on what subset of transactions the full node downloads, as it downloads all of them. Additionally the full node never explicitly advertises its addresses. Similarly as it verifies all blocks it is not vulnerable to double-spend or invalid transaction acceptance attacks.

\subsection{BIP-37 SPV}
For SPV the bandwidth is $O(n+y)$. $O(n)$ due to all block headers and $O(y)$ due to all (hopefully) relevant transactions downloaded. For each block header verification takes place and for each relevant transaction verification of its attached Merkle proof takes place, thus client computation is also $O(n+y)$. BIP-37 SPV's weak point is in server computation however, as the server looks though every single transaction in history to evaluate if it matches the bloom filter or not, thus it has the worst server computation complexity of all proposals, $O(n+m)$. Again, any full node can participate in the BIP-37 SPV network as a server. Addresses are not directly provided to the server, and some of the transactions detected as relevant by the server may not actually implicate the user, due to the bloom filter's false positive rate. The false positive rate is configurable and privacy-minded users may set a high false positive rate so as to create noise, but this comes at the cost of bandwidth. We conclude that this proposal does leak information about the user's addresses to the server. Double-spending and invalid transaction acceptance attacks are infeasible due to SPV security, which states that as long as the adversarial mining power is upper bounded by $50\%$ of the total mining power the block contents of the stable part of the best chain are valid.

\subsection{Electrum}
In Electrum the client receives all chain headers similar to BIP-37 SPV, and then processes all relevant transactions relayed by the primary server resulting in $O(n+y)$ bandwidth and $O(n+y)$ computation. The server however, simply relays all block headers, and because it maintains an index of addresses to transactions where it can just look up the client's advertised addresses its computation is $O(y)$. Server addresses are hardcoded in the Electrum software so participation is limited. Addresses are directly leaked to the servers for efficiency. Double spend and invalid transaction acceptance attacks are again impossible due to SPV security.

\subsection{Neutrino}
Neutrino downloads all chain headers and for each transaction of interest the full block it belongs to, yielding $O(n+y)$ bandwidth. The client needs to verify the header chain, compare its filter to each block filter to detect relevant transactions and verify the full blocks received match the corresponding blocks in the header chain, yielding a client computation of $O(n+y)$. The strong point of Neutrino is server computation. The server simply acts as a relay of information so the computation is constant. Neutrino is planned to be integrated in the full node P2P protocol which makes participation open. Addresses are not leaked directly, however full blocks are only received when they contain transactions of interest which could yield some information about the identity of the client to an adversary. Due to SPV security other attacks are impossible.

\subsection{Yoroi}
Yoroi only downloads purported relevant transactions from the explorer, which is $O(y)$. It simply stores the transactions and maintains a UTXO set, which yields $O(y)$ computation on the client. The server simply looks up the transactions of the provided addresses on an index and returns all of them, resulting in $O(y)$ computation. As the server address is hardcoded in the software, this is not a P2P protocol and participation is not open. Addresses are leaked directly to the server. The client does not perform any check that the transactions are actually valid or that they belong in the best chain, thus a double spend attack is feasible.

\section{Transparent Account-based Wallets}

For simplicity and without loss of generality we assume an Ethereum-like cryptocurrency.

Because in the account model there is no need for change outputs, new addresses are not automatically derived by wallets. New addresses are derived and used only by the explicit request of the user. Traditionally account-based wallets only hold a single address and public key, and we will assume the same in this section for simplification.

A transaction description is comprised of the address of the recipient, an amount of cryptocurrency and a fee. In Ethereum this fee takes the form of a gas price.
%TODO cite
To fund a transaction description the wallet performs the following steps:

\begin{enumerate}
    \item Fill in a valid address corresponding to a public key that:
    \begin{enumerate}
        \item holds at least as much cryptocurrency in its balance than what will be spent in the transaction and
        \item is derivable from the seed.
    \end{enumerate}
    \item Fill in the valid nonce in order to make this transaction spendable.
    \item Sign the transaction with the appropriate secret key.
\end{enumerate}

The transaction can subsequently be broadcast and accepted by the network.

We remark that an account-based wallet may offer limited functionality. For example, having access to the state it is easy to know the nonce and balance of any address of interest, thus funding a transaction description is straightforward. State however does not allow us to obtain the transaction history.

\subsection{Full Node}
A full node has access to the complete state and the full chain (i.e. all blocks and all their transactions), after a sync. For each derivable address, its balance and nonce can be looked up directly from the state. To obtain the transaction history for a set of addresses, every tranaction from the genesis block up to the tip must be checked.

\subsection{Metamask}
Metamask connects to a trusted web3 server and communicates with it over JSON-RPC in order to
\begin{enumerate}
    \item query the address' balance (via \texttt{getBalance})
    \item obtain the address' nonce (via \texttt{getTransactionCount})
\end{enumerate}

An explorer is used in order to obtain the transaction history, namely Etherscan.

\section{Light Wallets}
\begin{definition}[Light wallet]
A wallet is called \emph{light} if it can be usable in all 3 aspects (transaction description funding, balance and transaction history) by having a communication complexity of $o(n+m)$.
%TODO: not right. I need to talk about how many blocks, how much data and how much auxillary information must be transmitted, which doesn't seem like it can be captured very well with asymptotics.
\end{definition}

\begin{definition}[Light client]
A \emph{light client} is an ITM that after communicating with a set of parties $P$ of which at least one is honest, can determine by using $o(n)$ of communication:
\begin{enumerate}
    \item The tip of the honest chain.
    \item The inclusion of some block in the honest chain.
\end{enumerate}
\end{definition}

A parallel must be drawn to the verifier in~\cite{nipopows}. The verifier is non-interactive whereas we also allow interactive protocols for a light client. In NIPoPoWs a proof for the tip of the chain is called a suffix proof and a proof for the inclusion of some block in a chain is called an infix proof. A final difference is that in NIPoPoWs the proof size is fixed as $O(polylog(n))$ whereas our definition is more general, allowing any sublinear proof size.

\begin{acks}
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{refs}

\appendix

\section{Appendix Section 1}

\end{document}

\section{Preliminaries}
\subsection{The UTXO Model}
In the UTXO model a transaction consists of inputs and outputs. An output consists of an amount and a locking script (called \texttt{scriptPubKey} in Bitcoin). In Bitcoin the locking script is described in a stack-based language called Bitcoin Script. An input consists of an unlocking script (called \texttt{scriptSig} in Bitcoin) and an output pointer (also called an outpoint) which is a tuple of the form \tpl{\texttt{txID}, \texttt{outputIndex}}. We say that an input \emph{spends} an output, where \texttt{txID} refers to the transaction id that includes the output and \texttt{outputIndex} refers to the zero-based index of the output to be spent in that transaction.

\def\btcstate{\ensuremath{\sigma_\text{btc}}}
\def\btcapply{\text{apply}\textsubscript{btc}}
\def\outputs{\texttt{outputs}}
\def\inputs{\texttt{inputs}}
\def\spentOutputs{\texttt{spentOutputs}}
\def\utxo{\texttt{utxo}}
The global state of UTXO based cryptocurrencies includes all transaction outputs, and all spent transaction outputs. UTXO stands for unspent transaction outputs, which can trivially be computed from this state as $\btcstate.\utxo \triangleq \btcstate.\outputs \setminus \btcstate.\spentOutputs$.

An input is valid with regards to a state $\btcstate$ if (a) the output it references exists (i.e. $\in \btcstate.\outputs$) and is not already spent (i.e. $\notin \btcstate.\spentOutputs$) and (b) the unlocking script of the input ``unlocks'' the locking script of the output. In the case of Bitcoin, the unlocking script runs on an empty stack, and subsequently the locking script runs on the resulting stack of the unlocking script's execution. The input is considered to unlock the output if the locking script terminates successfully.

The transaction as a whole is valid if all inputs are valid and the sum of the values generated by its outputs is at most the sum of the values brought in by its inputs. The fee is defined as the absolute difference between the two sums. The state can be updated by a valid transaction as shown in \cref{alg.btcapply}, where the new outputs are added and newly spent outputs are marked as such.

The most usual form of output is Pay-to-Public-Key-Hash (P2PKH), which as its name implies includes the public key hash of the recipient. For an input spending it to be valid, it needs to contain a signature of the corresponding secret key over the new transaction skeleton and the output to be spent.

Money generation happens with coinbase transactions. A coinbase transaction is a special exception of a transaction that provides miners (in Proof-of-Work based cryptocurrencies) or minters (in Proof-of-Stake based cryptocurrencies) with their reward. Each block may have a single coinbase transaction. The coinbase transaction contains no inputs and generates only as much value as is considered the block reward per the consensus rules, plus any transaction fees.

\begin{algorithm}[H]
    \caption{\label{alg.btcapply} The $\btcapply$ function given a state $\btcstate$ and a transaction $tx$.}
    \begin{algorithmic}[1]
        \Function{$\btcapply$}{$\btcstate, tx$}
            \For{$o \in tx.\outputs$}
                \State{$\btcstate.\outputs \cupeq \{o\}$}
            \EndFor
            \For{$i \in tx.\inputs$}
                \State{$\btcstate.\spentOutputs \cupeq \{i.\texttt{output}\}$}
            \EndFor
            \State\Return{$\btcstate$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\subsection{The Account Model}
In the account model, a transfer transaction consists of a sender, a receiver, an amount, a nonce, a fee and a signature. The sender and receiver are public keys. The fee acts as an additional miner reward as in the UTXO model.

\def\state{\text{state}}
\def\chain{\ensuremath{\mathcal{C}}}
\def\sender{\texttt{sender}}
\def\receiver{\texttt{receiver}}
\def\amount{\texttt{amount}}
\def\fee{\texttt{fee}}
\def\nonce{\text{nonce}}
\def\bal{\text{balance}}
\def\ethstate{\ensuremath{\sigma_\text{eth}}}
For a transfer transaction to be valid with respect to a state $\ethstate$, the following conditions need to hold. We assume a function $\state(\chain)$ that returns the state of the world according to $\chain$. With $\ethstate[\texttt{address}]$ we denote the state of the account with the specified address.

\begin{itemize}
    \item The signature must be valid and generated by the secret key of the sender over the rest of the transfer transaction.
    \item The nonce must be equal to $\ethstate[\sender].\nonce + 1$.
    \item The sender must have adequate balance.
    \[
        \ethstate[\sender].\bal \ge \amount+\fee
    \]
\end{itemize}

We remark that the nonce is necessary in order to avoid replay attacks, for if it was absent some receiver would be able to repeat the same transaction ad infinitum until the sender account is completely drained. Note that a potential solution to this would be to maintain a set of processed transaction ids and add a requirement that the transaction to be evaluated for validity does not belong in that set. If the sender ever wishes to send the same amount to the same recipient, they will need to generate a new signature and thus the transaction will have a different transaction id. In theory this solution stands, however in practice due to the malleability of ECDSA a signature can be modified in a way that it changes and consequently the transaction id changes, while retaining its validity.

\def\ethapply{\text{apply}\textsubscript{eth}}

A valid transaction according to a state can be applied to it to generate a new state. We perform this state transformation with a function $\ethapply(\ethstate, tx)$ which debits the sender, credits the receiver and increments the sender's nonce. The full definition of $\ethapply$ is given in \cref{alg.ethapply}.

\begin{algorithm}[H]
    \caption{\label{alg.ethapply} The $\ethapply$ function given a $\ethstate$ and a transaction.}
    \begin{algorithmic}[1]
        \Function{$\ethapply$}{$\ethstate, tx$}
            \State{$\plusplus\ethstate[tx.\sender].\nonce$}
            \State{$\ethstate[tx.\sender].\bal \minuseq tx.\amount$}
            \State{$\ethstate[tx.\receiver].\bal \pluseq tx.\amount$}
            \State\Return{$\ethstate$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

Coinbase transactions could exist in account-based cryptocurrencies, for example having a $\sender$ field of all zeros. In practice Ethereum-based cryptocurrencies don't have them but instead directly include the miner's address inside the block header. For our purposes we will not consider the change of state due to miner rewards.

\subsection{SPV Security}
\begin{definition}[SPV client]
An \emph{SPV client} is an ITM that knows a genesis block \textsf{Gen} connects to a set of full nodes $\mathcal{P}$, at least one of which is honest. It may only request block headers at a range of heights. It obtains all header-chains $\chain_1, \dots, \chain_{|\mathcal{P}|}$, keeping only those for which the chain structure holds ($\forall 1 < i \le |\chain|: H(\chain[i-1]) = \chain[i].previd$). It subsequently compares them and adopts the chain with the most difficulty.
\end{definition}

We state some theorems pertaining to the adopted chain of an SPV client which are derivable from the works of~\cite{backbone,garay2017bitcoin,pass2017analysis}.

\begin{definition}[Honest majority assumption]
The adversarial mining power is at all times upper bounded by the half of the total mining power of the network.
\end{definition}

\begin{theorem}[SPV security]
Under the honest majority assumption, the stable part of an SPV client's adopted chain $\chain[:-k]$ is a prefix of the chain of the honest full node.
\end{theorem}

\begin{corollary}
Under the honest majority assumption, the underlying full chain of the stable part of an SPV client's adopted chain is syntactically valid.
\end{corollary}
